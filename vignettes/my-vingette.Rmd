---
title: "Variable-Resolution Heat Maps"
author: "Chris Comiskey"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Variable-resolution Heat Maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, fig.height=2, fig.width=2, message=FALSE, warning=FALSE}
  library(ggplot2)
  devtools::load_all()
  data(hitter)
```

Imagine you have a great spatial dataset with observations of some response across a continuous domain, and you want to make a heat map. However, some regions of the domain have way more observations than others. As a result, you're having trouble choosing a resolution. Not only that, you wish you could somehow convey this varying data density in your heat map. Variable-resolution (VR) heat maps to the rescue! 

VR maps allow you to integrate region appropriate resolutions, and simultaneously convey the relative data densities in those regions. The `varyres(...)` function in this package transforms your data into the data frame necessary to make a VR heat map. This vignette will introduce a motivating dataset, then walk you through how to use `varyres(...)` to create the VR heat map of your dreams.

## Data: `hitter`

We use the dataset `hitter` to motivate and demonstrate `varyres(...)`. The `hitter` dataset contains `r dim(hitter)[1]` observations, one for each swing baseball player Jhonny Peralta took between 2008 and 2015. Each observation consists of a pitch location and a swing outcome. The PITCHf/x data, as it is known, comes from [Sportvision, Inc](http://www.sportvision.com/) in conjunction with [Major League Baseball Advanced Media](http://www.mlbam.com/).

```{r}
dim(hitter)
head(hitter)
```

`hitter` has four columns, or four variables, for each swing.

* `x` gives the horizontal location of the pitch as it passes through the strike zone, in feet from the middle of home plate.
* `y` gives the vertical location of the pitch as it passes through the strike zone, in feet from the ground.
* `res` is a Bernoulli random variable that equals 1 if the swing was successful, and 0 if not.
* `des` gives a short description of the play.

## Motivation

A statistician chooses a resolution for his/her heat map, just like he/she does for a histogram. As you probably know, this can have a large impact on how your plot looks. How do you choose? What if you have far more data in one region of the domain than another? Let's look at a scatterplot of the `hitter` data to explore resolution selection.

```{r, echo = FALSE, fig.show = "hold", fig.align = "center"}
  library(ggplot2)

  ggplot(hitter, aes(x, y)) +
    geom_point(size = 0.5, alpha = 1/5) +
    coord_equal() +
  labs(title = "Peralta Swing Locations",
  x = "Feet from \n Middle of Home Plate",
  y = "Feet Off Ground") +
  theme(plot.title = element_text(hjust = 0.5))
```

If the whole domain looked as dense as the center we would choose one resolution; but if it looked as sparse as the edges we would choose another. Which region should primarily inform our choice? These maps give a few possibilities.

```{r, echo=FALSE, fig.height=2, fig.width=2, message=FALSE, warning=FALSE}
vr <- varyres(data = hitter, cutoff = 1, max = 4)

mapit(vr[[3]]) + spec_fcn(g = FALSE) + theme(axis.title.x=element_blank(), axis.title.y=element_blank())

mapit(vr[[4]]) + spec_fcn(g = FALSE) +  theme(axis.title.x=element_blank(), axis.title.y=element_blank())

mapit(vr[[5]]) + spec_fcn(g = FALSE) +  theme(axis.title.x=element_blank(), axis.title.y=element_blank())
```

In map one the margins look great, but the middle boxes contain thousands of swings each; and the map conceals this fact, but more on that in a minute. The middle of the strike zone looks great in map three, but some boxes toward the margins now have zero observations. With VR heat maps we don't have to choose which region to base our decision on---we can have both!

Also, would it not be great if somehow our heat map conveyed the varying density? Ask and you shall receive!

## A Variable-Resolution Heat Map

VR heat maps choose resolution for a particular area based on the data density in that particular area. The function `varyres(...)` creates, from your data set, a VR-ready data frame. From there we can easily use `ggplot2` to create the VR heat map. 

The main choice when creating a VR heat map is the "cutoff." The VR algorithm works by subdividing individual grid boxes until their sample size drops below a user-specified threshold---the `cutoff` argument in `varyres`. We use `cutoff = 200` with Peralta's `hitter` data to get this VR heat map.

```{r, eval = FALSE}
varyres(data = hitter, cutoff = 200, max = 4)
```

```{r, fig.align = "center", echo = FALSE}
vr <- varyres(data = hitter, cutoff = 200, max = 4)
mapit(vr[[5]]) + spec_fcn()
```
Here we see quite fine resolution in the center, more coarse resolution around the edges, and somewhere in-between as needed. Also, notice how the box sizes implicitly convey the varying density: bigger boxes correspond to less data, smaller boxes to more data. The sample sizes printed on the grid boxes here explicitly show this correspondence.
```{r, echo = FALSE, fig.align = "center"}
ggplot(vr[[5]], aes(x = x, y = y)) +
  with(vr[[5]], geom_tile(aes(fill = statistic), width = width, height = height)) +
  coord_equal() +
  scale_fill_distiller(palette = "Spectral", guide = FALSE) +
  geom_text(aes(label = count), size = 2)
```

The `cutoff` argument mentioned above gives you control over how populated you want the boxes to be. For example, `cutoff = 100` gives this map.

```{r, fig.align = "center", echo = FALSE}
vr <- varyres(data = hitter, cutoff = 100, max = 5)
mapit(vr[[6]]) + spec_fcn()
```

## Enjoy the Show

If you want to see how your VR map took evolved, you're in luck; `varyres(...)` stores the map at each iteration.

```{r, fig.width = 1.5, fig.height = 1.5, echo = FALSE}
mapit(vr[[1]]) + spec_fcn(g = FALSE) + nal_fcn()
mapit(vr[[2]]) + spec_fcn(g = FALSE) + nal_fcn()
mapit(vr[[3]]) + spec_fcn(g = FALSE) + nal_fcn()
mapit(vr[[4]]) + spec_fcn(g = FALSE) + nal_fcn()
mapit(vr[[5]]) + spec_fcn(g = FALSE) + nal_fcn()
mapit(vr[[6]]) + spec_fcn(g = FALSE) + nal_fcn()
```

## Summary

So there you have it. VR heat maps have arrived. No longer do analysts and PhD students have to wrestle with which resolution to choose for their heat maps.
